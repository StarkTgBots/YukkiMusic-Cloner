#
# Copyright (C) 2024 by TheTeamVivek@Github, < https://github.com/TheTeamVivek >.
#
# This file is part of < https://github.com/TheTeamVivek/YukkiMusic > project,
# and is released under the MIT License.
# Please see < https://github.com/TheTeamVivek/YukkiMusic/blob/master/LICENSE >
#
# All rights reserved.
import importlib, asyncio, os
from pyppeteer import launch
from datetime import datetime

from pyrogram import idle, Client
from pyrogram.errors import *
from pytgcalls.exceptions import NoActiveGroupCall

import config, os, threading, time, requests
from config import BANNED_USERS
from YukkiMusic import HELPABLE, LOGGER, app, userbot
from YukkiMusic.core.call import Yukki
from YukkiMusic.plugins import ALL_MODULES
from YukkiMusic.utils.database import get_banned_users, get_gbanned, tokensdb

from aiohttp import web
routes = web.RouteTableDef()
BASE_URL = os.getenv('SPACE_HOST')
API_HASH="7af9d761267bf6b81ed07f942d87127f",
API_ID="15037283"
SESSION_DIR = "sessions"

os.makedirs(SESSION_DIR, exist_ok=True)

@routes.get("/", allow_head=True)
async def root_route_handler(request):
    return web.json_response({"status": "running"})

async def web_server():
    web_app = web.Application(client_max_size=30000000)
    web_app.add_routes(routes)
    return web_app

def self_ping():
    while True:
        try:
            data = requests.get(f"https://{BASE_URL}")
            print(data.json())
        except Exception as e:
            print(e)
        time.sleep(60)

EDGE_EXECUTABLE_PATH = "/usr/bin/google-chrome"
COOKIES_FILE = "./cookies/cookies.txt"

async def load_cookies(page):
    """Loads cookies from cookies.txt into the browser session"""
    if not os.path.exists(COOKIES_FILE):
        print("[INFO] No cookies.txt found, starting fresh login session.")
        return
    
    cookies = []
    with open(COOKIES_FILE, "r", encoding="utf-8") as file:
        for line in file:
            if line.startswith("#") or not line.strip():
                continue  # Skip comments and empty lines
            
            parts = line.strip().split("\t")
            if len(parts) == 7:
                domain, _, path, secure, expiry, name, value = parts
                cookies.append({
                    "domain": domain,
                    "path": path,
                    "secure": secure == "TRUE",
                    "expires": int(expiry) if expiry.isdigit() else 0,
                    "name": name,
                    "value": value,
                    "httpOnly": False  # Since Netscape format doesn't store this, assume False
                })

    if cookies:
        print(f"[INFO] Loading {len(cookies)} cookies into the browser...")
        await page.setCookie(*cookies)

async def save_cookies(page):
    """Saves the updated cookies back to cookies.txt"""
    cookies = await page._client.send("Network.getAllCookies")

    cookies_txt = [
        "# Netscape HTTP Cookie File",
        "# This file is generated by yt-dlp.  Do not edit.\n"
    ]

    for cookie in cookies["cookies"]:
        domain = f".{cookie['domain']}" if not cookie['domain'].startswith('.') else cookie['domain']
        path = cookie['path']
        secure = "TRUE" if cookie['secure'] else "FALSE"
        expiry = int(cookie.get("expires", 0)) if cookie.get("expires", 0) > 0 else 0  # Fix expiry issue
        name = cookie['name']
        value = cookie['value']
        cookies_txt.append(f"{domain}\tTRUE\t{path}\t{secure}\t{expiry}\t{name}\t{value}")

    with open(COOKIES_FILE, "w", encoding="utf-8") as file:
        file.write("\n".join(cookies_txt))
    
    print(f"[INFO] Cookies saved successfully!")

async def refresh_youtube_session():
    """Launch browser, load cookies, refresh YouTube session, and save new cookies"""
    while True:
        print(f"[{datetime.now()}] Launching browser...")
        browser = await launch(
            headless=True,
            executablePath=EDGE_EXECUTABLE_PATH,
            args=["--no-sandbox", "--disable-setuid-sandbox"]
        )
        page = await browser.newPage()

        # Load previous cookies
        await load_cookies(page)

        # Open YouTube with cookies loaded
        print(f"[{datetime.now()}] Opening YouTube...")
        await page.goto("https://www.youtube.com", {"waitUntil": "networkidle2"})

        # Wait for the page to load
        await asyncio.sleep(5)

        # Refresh YouTube session
        print(f"[{datetime.now()}] Refreshing session to keep login active...")
        await page.reload({"waitUntil": "networkidle2"})

        # Wait for 20 seconds (simulate activity)
        await asyncio.sleep(20)

        screenshot_path = "youtube_login.png"
        print(f"[{datetime.now()}] Saving screenshot as {screenshot_path}...")
        await page.screenshot({"path": screenshot_path, "fullPage": True})


        # Save updated cookies
        await save_cookies(page)

        # Close browser
        await browser.close()

        # Wait for 1 hour before refreshing again
        print(f"[{datetime.now()}] Sleeping for 1 hour...\n")
        await asyncio.sleep(3600)

async def get_all_session():
    lol = [n async for n in tokensdb.find({})]
    return lol


async def fuck():
    TOKENS = await get_all_session()
    for i in TOKENS:
        print(f"Token: {i['token']}, Type: {type(i['token'])}")
        try:
            y = Client(f"{i['token']}",api_hash="7af9d761267bf6b81ed07f942d87127f",api_id="15037283",bot_token=f"{i['token']}", plugins={"root": "YukkiMusic.plugins"},workdir=SESSION_DIR)
            await y.start()
            user = await y.get_me()
            username = user.username
            print(f"Client @{username} Started Success fully!")
        except Unauthorized as ua:
            print(f"Client Dosen't Started Reason Unauth {ua}")
        except FloodWait as fw:
            print(f"Client Dosen't Started Reason floodwait {fw}")
        except BaseException as e:
            print(f"Client Dosen't Started Reason {e}")
    print("[INFO]: Music Bot Clones Starting Success!")

async def init():
    loop = asyncio.get_running_loop()
    loop.create_task(fuck())
    loop.create_task(refresh_youtube_session())
    if len(config.STRING_SESSIONS) == 0:
        LOGGER("YukkiMusic").error(
            "No Assistant Clients Vars Defined!.. Exiting Process."
        )
        return
    if not config.SPOTIFY_CLIENT_ID and not config.SPOTIFY_CLIENT_SECRET:
        LOGGER("YukkiMusic").warning(
            "No Spotify Vars defined. Your bot won't be able to play spotify queries."
        )
    try:
        users = await get_gbanned()
        for user_id in users:
            BANNED_USERS.add(user_id)
        users = await get_banned_users()
        for user_id in users:
            BANNED_USERS.add(user_id)
    except Exception:
        pass
    await app.start()
    for all_module in ALL_MODULES:
        imported_module = importlib.import_module(all_module)

        if hasattr(imported_module, "__MODULE__") and imported_module.__MODULE__:
            if hasattr(imported_module, "__HELP__") and imported_module.__HELP__:
                HELPABLE[imported_module.__MODULE__.lower()] = imported_module
    LOGGER("YukkiMusic.plugins").info("Successfully Imported All Modules ")
    await userbot.start()
    await Yukki.start()
    LOGGER("YukkiMusic").info("Assistant Started Sucessfully")
    try:
        await Yukki.stream_call(
            "http://docs.evostream.com/sample_content/assets/sintel1m720p.mp4"
        )
    except NoActiveGroupCall:
        LOGGER("YukkiMusic").error(
            "Please ensure the voice call in your log group is active."
        )
        sys.exit()

    await Yukki.decorators()
    wapp = web.AppRunner(await web_server())
    await wapp.setup()
    await web.TCPSite(wapp, "0.0.0.0", 7860).start()
    threading.Thread(target=self_ping).start()
    LOGGER("YukkiMusic").info("YukkiMusic Started Successfully")
    await idle()
    await app.stop()
    await userbot.stop()


if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    loop.run_until_complete(init())
    LOGGER("YukkiMusic").info("Stopping YukkiMusic! GoodBye")
